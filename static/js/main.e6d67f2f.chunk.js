(this["webpackJsonppersonal-site"]=this["webpackJsonppersonal-site"]||[]).push([[0],{39:function(e,t,a){},40:function(e,t,a){},41:function(e,t,a){},42:function(e,t,a){},48:function(e,t,a){},49:function(e,t,a){},50:function(e,t,a){},57:function(e,t,a){},58:function(e,t,a){"use strict";a.r(t);var i=a(1),s=a.n(i),n=a(23),r=a.n(n),o=(a(39),a(10)),c=a(2),l=(a(40),a(41),a(42),a(0)),h=function(){return Object(l.jsx)("div",{className:"Navigation-container",children:Object(l.jsxs)("ul",{className:"Navigation-list",children:[Object(l.jsx)("li",{children:Object(l.jsx)(o.b,{exact:!0,to:"/",className:"Navigation-link",activeClassName:"Navigation-link-active",children:"home"})}),Object(l.jsx)("li",{children:Object(l.jsx)(o.b,{to:"/portfolio",className:"Navigation-link",activeClassName:"Navigation-link-active",children:"portfolio"})}),Object(l.jsx)("li",{children:Object(l.jsx)(o.b,{to:"/contact",className:"Navigation-link",activeClassName:"Navigation-link-active",children:"contact"})})]})})},d=(a(48),function(){return Object(i.useEffect)((function(){return document.title="Home | Brendan Chess"}),[]),Object(l.jsxs)("div",{className:"Page-container",children:[Object(l.jsx)("img",{className:"Home-pfp",src:"https://firebasestorage.googleapis.com/v0/b/personal-site-280c7.appspot.com/o/bchess_circle_small.png?alt=media&token=12e24fee-d45d-42a1-a50c-3e7929d9a486"}),Object(l.jsx)("div",{className:"Page-divider"}),Object(l.jsx)("div",{className:"Page-title",children:"Brendan Chess"}),Object(l.jsx)("div",{className:"Page-divider"}),Object(l.jsx)("div",{className:"Page-paragraph",children:"React + React Native developer"}),Object(l.jsx)("div",{className:"Page-paragraph",children:"Senior at Arizona State University studying Computer Science"})]})}),m=a.p+"static/media/minesweeper_landing.dfd80455.png",u=a.p+"static/media/minesweeper_easy.916f8a27.png",p=(a(49),function(){return Object(i.useEffect)((function(){return document.title="Portfolio | Brendan Chess"}),[]),Object(l.jsxs)("div",{className:"Page-container Portfolio-container",children:[Object(l.jsx)("div",{className:"Page-divider"}),Object(l.jsx)("div",{className:"Page-title",children:"Portfolio"}),Object(l.jsx)("div",{className:"Page-divider"}),Object(l.jsxs)("div",{className:"Portfolio-sections",children:[Object(l.jsx)("div",{className:"Portfolio-section-title",children:"Projects"}),Object(l.jsx)("a",{href:"https://minesweepergame.io",target:"_blank",className:"Portfolio-section-subtitle",children:"minesweepergame.io"}),Object(l.jsx)("div",{className:"Portfolio-section-text",children:"My take on the classic game. I wanted to give minesweeper a cosmetic overhaul while keeping the same mechanics. It was built completely with React, is mobile friendly, and has no ads!"}),Object(l.jsxs)("div",{className:"Portfolio-section-gallery",children:[Object(l.jsx)("img",{className:"Portfolio-section-img",src:m}),Object(l.jsx)("img",{className:"Portfolio-section-img",src:u})]}),Object(l.jsx)("div",{className:"Portfolio-section-title",children:"Work Experience"}),Object(l.jsx)("div",{className:"Portfolio-section-subtitle",children:"Technical Co-Founder at Greek Rental LLC"}),Object(l.jsx)("div",{className:"Portfolio-section-text",children:"- Built company website from scratch using React, Firebase, and Stripe"}),Object(l.jsx)("div",{className:"Portfolio-section-text",children:"- Assisted in website design using Adobe XD"}),Object(l.jsx)("div",{className:"Portfolio-section-text",children:"- Participated in development of business strategy"}),Object(l.jsx)("div",{className:"Portfolio-section-subtitle",children:"Software Engineer Intern at RealTime Sports"}),Object(l.jsx)("div",{className:"Portfolio-section-text",children:"- Lead development of internal tools used for operating sports-based contests"}),Object(l.jsx)("div",{className:"Portfolio-section-text",children:"- Built components in user-facing iOS app with React Native and Firebase"}),Object(l.jsx)("div",{className:"Portfolio-section-text",children:"- Participated in daily stand-up meetings, followed agile process"})]})]})}),b=(a(50),a.p+"static/media/instagram.ff8a2cde.svg"),g=a.p+"static/media/linkedin.826d528e.svg",f=a.p+"static/media/github.f92762bf.svg",j=(a.p,function(){return Object(i.useEffect)((function(){return document.title="Contact | Brendan Chess"}),[]),Object(l.jsxs)("div",{className:"Page-container",children:[Object(l.jsx)("div",{className:"Page-divider"}),Object(l.jsx)("div",{className:"Page-title",children:"Contact"}),Object(l.jsx)("div",{className:"Page-divider"}),Object(l.jsx)("div",{className:"Page-paragraph Contact-email",children:"brendanchess25@gmail.com"}),Object(l.jsxs)("div",{className:"Contact-row",children:[Object(l.jsx)("a",{href:"https://www.instagram.com/brendan_chess/",children:Object(l.jsx)("img",{src:b})}),Object(l.jsx)("a",{href:"https://www.linkedin.com/in/brendan-chess-67196421b/",children:Object(l.jsx)("img",{src:g})}),Object(l.jsx)("a",{href:"https://github.com/brendan-chess",children:Object(l.jsx)("img",{src:f})})]})]})}),y=a(9),w=function(e){var t=e.title,a=e.date;return Object(l.jsxs)(l.Fragment,{children:[Object(l.jsx)("div",{class:"Article-title",children:t}),Object(l.jsx)("div",{class:"Article-author",children:Object(l.jsx)("span",{children:"by Brendan Chess"})}),Object(l.jsx)("div",{class:"Article-paragraph",children:a})]})},x=function(){return Object(i.useEffect)((function(){return document.title="Basics of Algorithm Analysis | Brendan Chess"}),[]),Object(l.jsx)("div",{class:"Article-container",children:Object(l.jsxs)("div",{class:"Article-body",children:[Object(l.jsx)(w,{title:"Basics of Algorithm Analysis",date:"January 2022"}),Object(l.jsx)("div",{class:"Article-paragraph",children:"Algorithms have become sort of a buzzword. You have probably heard about the YouTube algorithm, which determines which videos are recommended to you. You may even be familiar with how Spotify uses an algorithm to recommend new songs for you to listen to, based on music you already like. The public perception of algorithms is probably along the lines of \u201cthey do a lot of complicated things behind the scenes\u201d. But if you are studying computer science, then let's take a step back and define what algorithms are and discuss some basics that you should know about them."}),Object(l.jsx)("div",{class:"Article-paragraph",children:"An algorithm can simply be defined as a series of computational steps. Any program that you have written is essentially an algorithm. You could even consider a recipe for making a meal to be an algorithm. It really just comes down to being any set of instructions. Algorithms also tell us something; they always produce some sort of output. They are always given some input, and operate on that input to produce a result. Since the definition of an algorithm is so broad, the input and output can take many different forms. For instance, a pathfinding algorithm will output a set of driving directions for your road trip. A search engine\u2019s algorithm will output a list of web pages that are related to your query. Any sort of process that takes some input, performs a set of operations on that input, and returns some output, can be considered an algorithm."}),Object(l.jsx)("div",{class:"Article-paragraph",children:"When we talk about algorithms, we are usually concerned with their performance. By performance, we are talking about the time they take to run, and the space in memory they use. Instead of trying to quantify time and space, we actually just want to think about how much more time and space they take as they are provided with bigger inputs. The performance of an algorithm is related to the size of its input. For instance, you can imagine that a sorting algorithm would be quick to sort 10 numbers, but take much longer to sort 10 million numbers. But how much longer would it take? This growth in the algorithm's running time (and space used), as related to the size of its input, is known as its efficiency."}),Object(l.jsx)("div",{class:"Article-paragraph",children:"When talking about algorithm efficiency, we use a standard called Big-O notation. Big-O notation uses the variable \u2018n\u2019 to represent the size of an algorithm\u2019s input. We can describe the rate at which the runtime grows in terms of n. To do this, we have to analyze the code of an algorithm. As an example, let's look at an algorithm which prints every element in a list:"}),Object(l.jsx)("div",{class:"Article-code-block",children:Object(l.jsx)(y.a,{text:"function printList(list) {\n  for(let i = 0; i < list.length; i++) {\n    console.log(list[i]);\n  }\n}",language:"javascript",theme:y.b})}),Object(l.jsx)("div",{class:"Article-paragraph",children:"This code consists of a for loop, and the number of times that the loop iterates depends on the length of the input list. That length becomes our variable n in this case. If we were to add one more element to the list, then the for loop would iterate one more time. If we added 1 million more elements, then the for loop would iterate 1 million more times. The runtime of this algorithm grows in a linear fashion, as n increases. Because of that observation, this algorithm at least has a time complexity of O(n), read as \u201cbig O of n\u201d. We say at least because we may come across a worse time complexity later on in the code. The worst time complexity that we find is actually all that we use to describe the overall time complexity of the algorithm. We do that because the increase in runtime caused by other more efficient parts of code are insignificant compared to how much the least efficient parts will increase the runtime."}),Object(l.jsxs)("div",{class:"Article-paragraph",children:["To finish, we have to examine line 3. How much time does this line take? Accessing the ith element of the list will take the same amount of time if the list has 10 elements or 10 million elements. Following that, printing that element with ",Object(l.jsx)("span",{class:"Article-paragraph-code",children:"console.log()"})," also takes the same amount of time regardless of the size of the list. Therefore, this line runs in constant time; no matter what the size of the input list is, this line has the same runtime. In Big-O notation this is expressed as O(1), read as \u201cbig O of one\u201d. Because O(1) is more efficient than O(n), and we have analyzed all lines of code in this algorithm, we can conclude that the time-complexity of this algorithm is O(n), where n is the length of the input list. The space complexity of this algorithm is O(1) because the algorithm does not declare any variables. The amount of space used in memory from the start of the algorithm to when it finishes remains constant."]}),Object(l.jsx)("div",{class:"Article-paragraph",children:"In addition to O(1) and O(n), here are some other fundamental space-time complexities that you will encounter:"}),Object(l.jsx)("div",{class:"Article-paragraph",children:"\u2022 O(logn) and O(nlogn) - These runtimes often occur in algorithms that operate on tree data structures. This happens because the height of a tree equals logn."}),Object(l.jsx)("div",{class:"Article-paragraph",children:"\u2022 O(n\xb2) - Just as a for-loop creates an O(n) runtime, a double for-loop creates an O(n\xb2) time. This is because you are performing n operations on each element in an input of size n."}),Object(l.jsx)("div",{class:"Article-paragraph",children:"Analyzing the efficiency of algorithms gets much more complicated than this. One topic to look out for if you are learning about algorithms in school is recurrence relations, which describe the efficiency of recursive algorithms. Also, conditional statements (like if and while) are a bit tricky. They don\u2019t necessarily have a relationship with the size of the input, yet they can still have an influence on space-time complexity. Regardless, I hope that this article gave you, or has strengthened your understanding of the basic ideas about algorithms and what you should know about them."})]})})},v=function(){return Object(i.useEffect)((function(){return document.title="Memory, Pointers, and Dynamic Programming | Brendan Chess"}),[]),Object(l.jsx)("div",{class:"Article-container",children:Object(l.jsxs)("div",{class:"Article-body",children:[Object(l.jsx)(w,{title:"Memory, Pointers, and Dynamic Programming",date:"January 2022"}),Object(l.jsx)("div",{class:"Article-paragraph",children:"It\u2019s important to understand not just how to write code, but what our computer actually does when we run our code. When we run code, it makes use of memory in our computer. Memory is often called RAM, which is short for random access memory. Random access means that the time memory is used and amount of memory that is used can vary. In other words, memory is a big space that is available for any program to use at any time, in any way that it needs to. But what exactly does memory look like, and how does it relate to the code we write? Let\u2019s get into those details."}),Object(l.jsx)("div",{class:"Article-paragraph",children:"Physically, memory is a piece of hardware that is part of your computer, and can come in many sizes. An average amount of memory to have in a computer these days might be around 8 to 16 gigabytes. As the computer sees it, memory is just a long list of 1\u2019s and 0\u2019s. Each space that holds a 1 or 0 is known as a bit. A bit is the smallest denomination of memory. When the computer interacts with memory, it actually doesn\u2019t view the individual bits one by one; instead, it groups memory into cells, each cell composed of 8 bits. The reason for this is that a single bit on its own has little use, so it was decided that grouping them together to form a more useful unit would be more efficient. That grouping of 8 bits is known as a byte, and is the standard unit that we use when we talk about memory in a computer. The choice of exactly 8 bits is somewhat arbitrary, as other sizes have been used to define a byte in the earlier days of computers. It just turned out that 8 became the most popular and widely accepted number, and as such it remains standard today."}),Object(l.jsx)("div",{class:"Article-paragraph",children:"Each byte in memory is given a unique identifier. This is called a byte\u2019s address. An address is a number, formatted in hexadecimal. Because memory is like a long list of bytes, the address of a byte increases by one from the byte before it. The byte with address 6 has byte 5 before it, and byte 7 after it."}),Object(l.jsx)("div",{class:"Article-paragraph",children:"When we declare a variable in our program, the computer will choose a byte in memory that isn\u2019t being used and reserve that byte. This byte\u2019s address is now associated with that variable. The value assigned to the variable will be stored there. This process takes place at the beginning of a program\u2019s execution. It is known as static allocation."}),Object(l.jsxs)("div",{class:"Article-paragraph",children:["A caveat to this is that not all data types can fit in one byte. Many data types require more than one byte of space in memory. In this case, multiple bytes are allocated for a variable. The bytes will all be next to each other and are allocated at the same time. The most common data types that are larger than one byte include ",Object(l.jsx)("span",{class:"Article-paragraph-code",children:"int"})," at 4 bytes, ",Object(l.jsx)("span",{class:"Article-paragraph-code",children:"float"})," at 4 bytes, and ",Object(l.jsx)("span",{class:"Article-paragraph-code",children:"double"})," at 8 bytes. The ones that will fit in one byte are ",Object(l.jsx)("span",{class:"Article-paragraph-code",children:"char"})," and ",Object(l.jsx)("span",{class:"Article-paragraph-code",children:"boolean"}),"."]}),Object(l.jsxs)("div",{class:"Article-paragraph",children:["What about arrays? Well, consider an example of how an array is declared: ",Object(l.jsx)("span",{class:"Article-paragraph-code",children:"int numbers[10]"}),". One ",Object(l.jsx)("span",{class:"Article-paragraph-code",children:"int"})," takes up 4 bytes in memory. This array will store 10 of them. Therefore, we need 4 x 10 = 40 bytes. Again, these bytes will all be located next to each other in memory."]}),Object(l.jsx)("div",{class:"Article-paragraph",children:"So this is how memory is allocated when we declare a variable. The computer begins execution of our program by looking through all of the variable declarations in our code and reserving the required bytes in memory. When we allocate memory statically like this, we know how much space we will use. But what if we want our code to be more flexible and have the ability to use varying amounts of memory on each run?"}),Object(l.jsxs)("div",{class:"Article-paragraph",children:["To picture this, let\u2019s consider a program that asks a user for a list of ingredients in a recipe. Our program will store those ingredients in an array. One issue we run into is that not all recipes will have the same number of ingredients. So what should the size of our array be? It\u2019s not efficient to set a constant size for the array, such as ",Object(l.jsx)("span",{class:"Article-paragraph-code",children:"string ingredients[10]"}),". But our code won\u2019t compile unless we do this. To solve this problem, let\u2019s talk about how we can access memory dynamically as our program runs. It turns out that we can ask the user what the appropriate size should be before we allocate space."]}),Object(l.jsxs)("div",{class:"Article-paragraph",children:["The technique of allocating memory while our program is running is known as dynamic programming. To do this, we actually don\u2019t declare regular variables; instead, we declare something called a pointer. A pointer is given a data type, just like a variable. An integer pointer would be declared like ",Object(l.jsx)("span",{class:"Article-paragraph-code",children:"int* number;"}),". The key idea is that the value of the pointer is actually a memory address. Its data type describes which kind of data is stored at that address. So if the value of ",Object(l.jsx)("span",{class:"Article-paragraph-code",children:"int* number"})," is 1000, then we would know that an integer is being stored at the byte with address 1000. The integer actually takes up bytes 1000-1003, since integers require 4 bytes of storage. However, ",Object(l.jsx)("span",{class:"Article-paragraph-code",children:"number"})," actually only stores the address of the first byte, 1000."]}),Object(l.jsxs)("div",{class:"Article-paragraph",children:["If we declare our ",Object(l.jsx)("span",{class:"Article-paragraph-code",children:"ingredients"})," array from before using a pointer, we don\u2019t have to provide it with a constant size. We can support storage of recipes that have any number of ingredients to them. The size can be determined while the program is running. First, we can ask the user how many ingredients are in their recipe, and store that in a variable. Then, we can use that variable as the size to declare ",Object(l.jsx)("span",{class:"Article-paragraph-code",children:"ingredients"})," with. Here is how we can code this:"]}),Object(l.jsx)("div",{class:"Article-code-block",children:Object(l.jsx)(y.a,{text:"int number_of_ingredients;\n\ncout << \u201cHow many ingredients are in your recipe?\u201d << endl;\ncin >> number_of_ingredients;\n\n// Use the new keyword to allocate memory with a pointer\nstring* ingredients = new string[number_of_ingredients];\n",language:"cpp",theme:y.b})}),Object(l.jsxs)("div",{class:"Article-paragraph",children:["A side effect of dynamic programming is that while we can allocate new memory during runtime, we should also free up that memory when we are done with it. It is possible that we can actually run out of memory. To free up memory we use the ",Object(l.jsx)("span",{class:"Article-paragraph-code",children:"delete"})," keyword. Using ",Object(l.jsx)("span",{class:"Article-paragraph-code",children:"delete"})," on a pointer tells it to stop referencing an address. Once that happens, that byte (or sequence of bytes) is no longer recognized as being used for anything. That space can be allocated for something else later on in the program\u2019s runtime. Here is how we would add this to our code from before:"]}),Object(l.jsx)("div",{class:"Article-code-block",children:Object(l.jsx)(y.a,{text:"int number_of_ingredients;\n\ncout << \u201cHow many ingredients are in your recipe?\u201d << endl;\ncin >> number_of_ingredients;\n\nstring* ingredients;\ningredients = new string[number_of_ingredients];\n\n// Do something with ingredients\n\ndelete[] ingredients;\n// All of the bytes in memory used by ingredients are now free\n",language:"cpp",theme:y.b})}),Object(l.jsxs)("div",{class:"Article-paragraph",children:["We attached the brackets to the ",Object(l.jsx)("span",{class:"Article-paragraph-code",children:"delete"})," keyword here because we are deleting an array. If your pointer is not referencing an array, you would just use the ",Object(l.jsx)("span",{class:"Article-paragraph-code",children:"delete"})," keyword on its own."]}),Object(l.jsx)("div",{class:"Article-paragraph",children:"There\u2019s a lot more that you can do with pointers and dynamic programming. In fact, pointers are the backbone to most programs and the data structures that they use. It really just becomes necessary to know how to allocate memory dynamically like this if we want to make more advanced programs. I think it\u2019s good to also keep the fundamental ideas in mind, though."})]})})},O=function(){return Object(l.jsxs)(l.Fragment,{children:[Object(l.jsx)(c.a,{exact:!0,path:"/basics_of_algorithm_analysis",children:Object(l.jsx)(x,{})}),Object(l.jsx)(c.a,{exact:!0,path:"/memory_pointers_and_dynamic_programming",children:Object(l.jsx)(v,{})})]})},A=(a(57),function(){return Object(l.jsx)("div",{className:"Footer",children:"\xa9 2022 Brendan Chess"})}),k=function(){return Object(l.jsxs)(o.a,{children:[Object(l.jsxs)("div",{className:"App-container",children:[Object(l.jsx)(h,{}),Object(l.jsxs)(c.c,{children:[Object(l.jsx)(c.a,{exact:!0,path:"/",children:Object(l.jsx)(d,{})}),Object(l.jsx)(c.a,{exact:!0,path:"/portfolio",children:Object(l.jsx)(p,{})}),Object(l.jsx)(c.a,{exact:!0,path:"/contact",children:Object(l.jsx)(j,{})}),Object(l.jsx)(O,{})]})]}),Object(l.jsx)(A,{})]})},N=function(e){e&&e instanceof Function&&a.e(155).then(a.bind(null,244)).then((function(t){var a=t.getCLS,i=t.getFID,s=t.getFCP,n=t.getLCP,r=t.getTTFB;a(e),i(e),s(e),n(e),r(e)}))};r.a.render(Object(l.jsx)(s.a.StrictMode,{children:Object(l.jsx)(k,{})}),document.getElementById("root")),N()}},[[58,152,153]]]);
//# sourceMappingURL=main.e6d67f2f.chunk.js.map